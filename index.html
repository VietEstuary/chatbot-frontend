<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PTB DECOFI Assistant</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: #f7f7f8;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .container {
            width: 100%;
            max-width: 1200px;
            padding: 20px;
        }

        .chat-container {
            width: 100%;
            height: 90vh;
            background: white;
            border-radius: 16px;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        .chat-header {
            padding: 15px 20px;
            position: relative;
            background: white;
            display: flex;
            align-items: center;
            border-bottom: 1px solid #f0f0f0;
        }

        .company-logo {
            height: 45px;
            margin-right: 15px;
        }
        
        .header-text {
            flex-grow: 1;
        }
        
        .header-text small {
             color: #8e8e93;
             font-size: 14px;
        }

        .connection-status {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 12px;
            color: #8e8e93;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .status-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .status-dot.online {
            background: #34c759;
            animation: pulse 2s infinite;
        }

        .status-dot.offline {
            background: #ff3b30;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .error-alert {
            display: none;
            margin: 0 20px 20px;
            padding: 16px;
            background: #fee;
            border: 1px solid #fcc;
            border-radius: 8px;
            color: #c00;
            font-size: 14px;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 15px 40px 20px;
            scroll-behavior: smooth;
            background: #fafafa;
        }

        .chat-messages::-webkit-scrollbar {
            width: 6px;
        }

        .chat-messages::-webkit-scrollbar-track {
            background: transparent;
        }

        .chat-messages::-webkit-scrollbar-thumb {
            background: #ddd;
            border-radius: 3px;
        }

        .message {
            margin-bottom: 20px;
            animation: fadeInUp 0.3s ease-out;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .user-message {
            text-align: right;
        }

        .user-message .message-content {
            display: inline-block;
            background: #007aff;
            color: white;
            padding: 12px 20px;
            border-radius: 20px 20px 4px 20px;
            max-width: 70%;
            word-wrap: break-word;
        }

        .bot-message {
            text-align: left;
        }

        .bot-message .message-content {
            display: inline-block;
            background: #e9ecef;
            color: #333;
            padding: 12px 20px;
            border-radius: 20px 20px 20px 4px;
            max-width: 70%;
            word-wrap: break-word;
            white-space: pre-wrap;
            line-height: 1.6;
            position: relative;
        }

        /* Typing cursor for streaming */
        .typing-cursor {
            display: inline-block;
            width: 2px;
            height: 1.2em;
            background-color: #007aff;
            animation: blink 1s infinite;
            margin-left: 2px;
            vertical-align: text-bottom;
        }

        @keyframes blink {
            0%, 49% { opacity: 1; }
            50%, 100% { opacity: 0; }
        }

        /* Enhanced formatting for bot responses */
        .bot-message .message-content strong {
            color: #000;
            font-weight: 600;
        }

        .bot-message .message-content em {
            color: #666;
            font-style: italic;
        }

        .bot-message .message-content ul,
        .bot-message .message-content ol {
            margin: 10px 0;
            padding-left: 20px;
        }

        .bot-message .message-content li {
            margin: 5px 0;
        }

        .bot-message .message-content code {
            background: #f4f4f4;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: monospace;
        }

        .typing-indicator {
            display: none;
            padding: 0 40px 20px;
            animation: fadeInUp 0.3s ease-out;
        }

        .typing-indicator span {
            display: inline-block;
            background: #e9ecef;
            padding: 12px 20px;
            border-radius: 20px 20px 20px 4px;
            color: #8e8e93;
            font-style: italic;
            font-size: 14px;
        }

        .input-area {
            padding: 30px 40px;
            background: white;
            border-top: 1px solid #f0f0f0;
        }

        .input-group {
            position: relative;
            background: #f7f7f8;
            border-radius: 32px;
            border: 1px solid #e5e5e7;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            padding: 0 8px 0 24px;
            min-height: 64px;
        }

        .input-group:focus-within {
            border-color: #007aff;
            box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.1);
        }

        #userInput {
            flex: 1;
            border: none;
            background: transparent;
            padding: 22px 0;
            font-size: 17px;
            outline: none;
            color: #1a1a1a;
            line-height: 1.4;
        }

        #userInput::placeholder {
            color: #8e8e93;
        }

        .input-group-append {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .btn {
            border: none;
            background: transparent;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            color: #8e8e93;
        }

        .btn:hover {
            background: #e5e5e7;
        }

        .btn-primary {
            background: #007aff;
            color: white;
            padding: 10px 20px;
            border-radius: 24px;
            font-size: 15px;
            font-weight: 500;
        }

        .btn-primary:hover {
            background: #0056b3;
        }

        .btn-primary:disabled {
            background: #c7c7cc;
            cursor: not-allowed;
        }

        .backend-info {
            position: absolute;
            bottom: 10px;
            right: 20px;
            font-size: 11px;
            opacity: 0.7;
            color: #8e8e93;
        }

        /* Quick actions */
        .quick-actions {
            padding: 10px 40px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .quick-action {
            padding: 8px 16px;
            background: #f0f0f5;
            border: 1px solid #e5e5e7;
            border-radius: 20px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .quick-action:hover {
            background: #007aff;
            color: white;
            border-color: #007aff;
        }

        /* Loading animation for messages */
        .message-loading {
            display: inline-block;
            width: 40px;
            text-align: center;
        }

        .message-loading:after {
            content: '...';
            animation: dots 1.5s steps(4, end) infinite;
        }

        @keyframes dots {
            0%, 20% { content: ''; }
            40% { content: '.'; }
            60% { content: '..'; }
            80%, 100% { content: '...'; }
        }

        @media (max-width: 768px) {
            .container {
                padding: 0;
            }

            .chat-container {
                height: 100vh;
                border-radius: 0;
            }
            
            .chat-header h2 {
                font-size: 24px;
            }

            .company-logo {
                height: 40px;
                margin-bottom: 10px;
            }
            
            .chat-messages {
                padding: 20px;
            }
            
            .input-area {
                padding: 20px;
            }
            
            .message-content {
                max-width: 85% !important;
            }

            .typing-indicator {
                padding: 0 20px 20px;
            }

            .quick-actions {
                padding: 10px 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="chat-container">
            <div class="chat-header">
                <div class="company-logo">
                    <img src="https://i.ibb.co/39HtzTxV/Decofi-logo.png" 
                         alt="DECOFI Logo" 
                         style="height: 65px; width: auto; object-fit: contain;">
                </div>
                
                <small>X√¢y d·ª±ng ch·ªØ t√≠n - Kh·∫≥ng ƒë·ªãnh ni·ªÅm tin</small>
                <div class="connection-status">
                    <span class="status-dot offline" id="statusDot"></span>
                    <span id="statusText">ƒêang k·∫øt n·ªëi...</span>
                </div>
            </div>
            
            <div class="error-alert" id="errorAlert">
                <strong>‚ö†Ô∏è L·ªói k·∫øt n·ªëi!</strong><br>
                <span id="errorMessage">Backend server ch∆∞a ch·∫°y. H√£y ch·∫°y: <code>npm start</code></span>
            </div>
            
            <div class="chat-messages" id="chatMessages">
                <!-- Messages will be added here -->
            </div>
            
            <div class="quick-actions" id="quickActions">
                <div class="quick-action" onclick="sendQuickMessage('T·ªìn kho c√πm xoay')">üì¶ T·ªìn kho</div>
                <div class="quick-action" onclick="sendQuickMessage('Ch·ªëng 4m n·∫∑ng bao nhi√™u?')">‚öñÔ∏è Tr·ªçng l∆∞·ª£ng ch·ªëng</div>
                <div class="quick-action" onclick="sendQuickMessage('10 ch·ªëng 2.5m n·∫∑ng bao nhi√™u')">üìä T√≠nh to√°n</div>
                <div class="quick-action" onclick="sendQuickMessage('Th√¥ng tin c√¥ng ty')">‚ÑπÔ∏è V·ªÅ DECOFI</div>
            </div>
            
            <div class="typing-indicator" id="typingIndicator">
                <span>PTB ƒëang so·∫°n tin...</span>
            </div>
            
            <div class="input-area">
                <div class="input-group">
                    <input type="text" 
                           id="userInput" 
                           placeholder="H·ªèi b·∫•t k·ª≥ ƒëi·ªÅu g√¨ ..."
                           onkeypress="if(event.key==='Enter' && !event.shiftKey) sendMessage()">
                    <div class="input-group-append">
                        <button class="btn btn-primary" id="sendButton" onclick="sendMessage()">
                            G·ª≠i
                        </button>
                    </div>
                </div>
                <div class="backend-info" id="backendInfo"></div>
            </div>
        </div>
    </div>

    <script>
        // Backend URL configuration
        const BACKEND_URL = window.location.hostname === 'localhost' 
            ? 'http://localhost:3000' 
            : 'https://chatbot-backend-viet.onrender.com';

        let isConnected = false;
        let isFirstLoad = true;
        let serverVersion = 'unknown';
        let currentEventSource = null;
        let typingTimeout = null; // Th√™m bi·∫øn ƒë·ªÉ l∆∞u timeout

        // Format message content with proper HTML
        function formatMessageContent(content) {
            if (!content) return '';
            
            return content
                .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.+?)\*/g, '<em>$1</em>')
                .replace(/`(.+?)`/g, '<code>$1</code>')
                .replace(/\n/g, '<br>');
        }

        // Add message to chat
        function addMessage(content, isUser = false, messageId = null) {
            const messagesDiv = document.getElementById('chatMessages');
            
            let messageDiv;
            if (messageId) {
                messageDiv = document.getElementById(messageId);
                if (!messageDiv) {
                    messageDiv = document.createElement('div');
                    messageDiv.id = messageId;
                    messageDiv.className = `message ${isUser ? 'user' : 'bot'}-message`;
                    messagesDiv.appendChild(messageDiv);
                }
            } else {
                messageDiv = document.createElement('div');
                messageDiv.className = `message ${isUser ? 'user' : 'bot'}-message`;
                messagesDiv.appendChild(messageDiv);
            }
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            
            if (isUser) {
                contentDiv.textContent = content;
            } else {
                contentDiv.innerHTML = formatMessageContent(content);
            }
            
            messageDiv.innerHTML = '';
            messageDiv.appendChild(contentDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            
            return messageDiv;
        }

        // Add streaming message with typing cursor
        function addStreamingMessage(content, messageId, isComplete = false) {
            const messagesDiv = document.getElementById('chatMessages');
            
            let messageDiv = document.getElementById(messageId);
            if (!messageDiv) {
                messageDiv = document.createElement('div');
                messageDiv.id = messageId;
                messageDiv.className = 'message bot-message';
                messagesDiv.appendChild(messageDiv);
            }
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            
            const formattedContent = formatMessageContent(content);
            if (!isComplete) {
                contentDiv.innerHTML = formattedContent + '<span class="typing-cursor"></span>';
            } else {
                contentDiv.innerHTML = formattedContent;
            }
            
            messageDiv.innerHTML = '';
            messageDiv.appendChild(contentDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        // Check backend connection
        async function checkBackendHealth() {
            const statusDot = document.getElementById('statusDot');
            const statusText = document.getElementById('statusText');
            const errorAlert = document.getElementById('errorAlert');
            const errorMessage = document.getElementById('errorMessage');
            const backendInfo = document.getElementById('backendInfo');

            try {
                const response = await fetch(`${BACKEND_URL}/health`, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json'
                    },
                    mode: 'cors'
                });
                
                if (response.ok) {
                    const data = await response.json();
                    isConnected = true;
                    statusDot.className = 'status-dot online';
                    statusText.textContent = 'ƒê√£ k·∫øt n·ªëi';
                    errorAlert.style.display = 'none';
                    backendInfo.textContent = `Backend: ${BACKEND_URL.replace('http://', '').replace('https://', '')}`;
                    
                    if (isFirstLoad) {
                        isFirstLoad = false;
                        showInitialGreeting();
                    }
                    
                    console.log('‚úÖ Backend connected:', data);
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
            } catch (error) {
                isConnected = false;
                statusDot.className = 'status-dot offline';
                statusText.textContent = 'M·∫•t k·∫øt n·ªëi';
                errorAlert.style.display = 'block';
                
                if (error.message.includes('fetch')) {
                    errorMessage.innerHTML = `Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn backend t·∫°i <code>${BACKEND_URL}</code><br>
                        Ki·ªÉm tra: 1) Server ƒëang ch·∫°y, 2) URL ƒë√∫ng, 3) CORS ƒë∆∞·ª£c c·∫•u h√¨nh`;
                } else {
                    errorMessage.innerHTML = `L·ªói k·∫øt n·ªëi: ${error.message}`;
                }
                
                backendInfo.textContent = 'Backend: Disconnected';
                console.error('‚ùå Backend error:', error);
            }
        }

        // Show initial greeting
        function showInitialGreeting() {
            addMessage(`üì¶ **Xin ch√†o! T√¥i l√† tr·ª£ l√Ω ·∫£o c·ªßa ph√≤ng thi·∫øt b·ªã DECOFI.**

T√¥i c√≥ th·ªÉ gi√∫p b·∫°n:
‚Ä¢ Tra c·ª©u t·ªìn kho v·∫≠t t∆∞
‚Ä¢ T√≠nh to√°n tr·ªçng l∆∞·ª£ng thi·∫øt b·ªã
‚Ä¢ Th√¥ng tin v·ªÅ c√¥ng ty DECOFI
‚Ä¢ V√† nhi·ªÅu th√¥ng tin kh√°c

üí° *H√£y th·ª≠ c√°c c√¢u h·ªèi m·∫´u b√™n d∆∞·ªõi ho·∫∑c g√µ c√¢u h·ªèi c·ªßa b·∫°n!*`);
        }

        // UPDATED SEND MESSAGE FUNCTION - ALWAYS USE STREAMING
        async function sendMessage() {
            if (!isConnected) {
                alert('‚ö†Ô∏è Ch∆∞a k·∫øt n·ªëi ƒë∆∞·ª£c v·ªõi server!\n\nVui l√≤ng ki·ªÉm tra:\n1. Server backend ƒëang ch·∫°y\n2. URL k·∫øt n·ªëi ƒë√∫ng');
                return;
            }

            const input = document.getElementById('userInput');
            const sendButton = document.getElementById('sendButton');
            const message = input.value.trim();
            
            if (!message) return;

            // Add user message
            addMessage(message, true);
            
            // Clear input and disable
            input.value = '';
            input.disabled = true;
            sendButton.disabled = true;
            
            // Show typing indicator
            const typingIndicator = document.getElementById('typingIndicator');
            typingIndicator.style.display = 'block';

            // TH√äM DELAY 3 GI√ÇY TR∆Ø·ªöC KHI G·ªåI STREAMING
            await new Promise(resolve => {
                typingTimeout = setTimeout(resolve, 3000); // 3 gi√¢y
            });

            try {
                // Always use streaming
                await sendStreamingMessage(message);
            } catch (error) {
                console.error('Chat error:', error);
                addMessage(`‚ùå **L·ªói:** ${error.message}\n\n*Vui l√≤ng th·ª≠ l·∫°i sau.*`);
            } finally {
                // Clear timeout if exists
                if (typingTimeout) {
                    clearTimeout(typingTimeout);
                    typingTimeout = null;
                }
                // Hide typing only if not streaming (error case)
                if (!currentEventSource) {
                    typingIndicator.style.display = 'none';
                }
                input.disabled = false;
                sendButton.disabled = false;
                input.focus();
            }
        }

        // Send normal message (without streaming)
        async function sendNormalMessage(message) {
            const response = await fetch(`${BACKEND_URL}/api/chat`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                },
                mode: 'cors',
                body: JSON.stringify({
                    question: message
                })
            });

            const data = await response.json();
            
            if (data.success && data.answer) {
                addMessage(data.answer);
                
                if (data.metadata) {
                    console.log('Response metadata:', data.metadata);
                }
            } else {
                throw new Error(data.error || 'Kh√¥ng c√≥ ph·∫£n h·ªìi t·ª´ server');
            }
        }

        // Send streaming message
        async function sendStreamingMessage(message) {
            // Close any existing EventSource
            if (currentEventSource) {
                currentEventSource.close();
            }

            // Create unique message ID for streaming
            const messageId = 'stream-' + Date.now();
            let fullResponse = '';
            let isStreamComplete = false;
            let firstChunkReceived = false; // Flag ƒë·ªÉ track chunk ƒë·∫ßu ti√™n

            // Create EventSource for streaming
            currentEventSource = new EventSource(
                `${BACKEND_URL}/api/chat/stream?question=${encodeURIComponent(message)}`
            );

            // Handle incoming chunks
            currentEventSource.onmessage = (event) => {
                try {
                    // Hide typing indicator only when first chunk arrives
                    if (!firstChunkReceived) {
                        document.getElementById('typingIndicator').style.display = 'none';
                        firstChunkReceived = true;
                    }
                    
                    const data = JSON.parse(event.data);
                    fullResponse += data.chunk;
                    
                    // Update message with typing effect
                    addStreamingMessage(fullResponse, messageId, data.isComplete);
                    
                    if (data.isComplete) {
                        isStreamComplete = true;
                    }
                } catch (error) {
                    console.error('Error parsing stream data:', error);
                }
            };

            // Handle completion
            currentEventSource.addEventListener('complete', (event) => {
                currentEventSource.close();
                currentEventSource = null;
                
                // Remove typing cursor
                addStreamingMessage(fullResponse, messageId, true);
                
                console.log('Streaming completed');
            });

            // Handle errors
            currentEventSource.onerror = (error) => {
                console.error('Streaming error:', error);
                currentEventSource.close();
                currentEventSource = null;
                
                // Hide typing indicator on error
                document.getElementById('typingIndicator').style.display = 'none';
                
                // If no response received, fall back to normal API
                if (!fullResponse) {
                    console.log('Falling back to normal API...');
                    sendNormalMessage(message).catch(err => {
                        addMessage(`‚ùå **L·ªói streaming:** Kh√¥ng th·ªÉ nh·∫≠n ph·∫£n h·ªìi t·ª´ server.`);
                    });
                } else {
                    // Just remove cursor if we have partial response
                    addStreamingMessage(fullResponse, messageId, true);
                }
            };
        }

        // Send quick action message
        function sendQuickMessage(message) {
            document.getElementById('userInput').value = message;
            sendMessage();
        }

        // Check version endpoint
        async function checkVersion() {
            try {
                const response = await fetch(`${BACKEND_URL}/api/chat/version`);
                if (response.ok) {
                    const data = await response.json();
                    serverVersion = data.version || 'unknown';
                    console.log('Server version:', data);
                }
            } catch (error) {
                console.log('Version check failed:', error);
            }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Ctrl/Cmd + Enter to send
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                sendMessage();
            }
            
            // ESC to clear input
            if (e.key === 'Escape') {
                document.getElementById('userInput').value = '';
            }
        });

        // Initialize on load
        window.addEventListener('load', async () => {
            await checkBackendHealth();
            await checkVersion();
            
            // Set up periodic health checks
            setInterval(checkBackendHealth, 30000);
            
            // Focus input
            document.getElementById('userInput').focus();
        });

        // Clean up EventSource on page unload
        window.addEventListener('beforeunload', () => {
            if (currentEventSource) {
                currentEventSource.close();
            }
            if (typingTimeout) {
                clearTimeout(typingTimeout);
            }
        });

        // Debug functions
        window.debug = {
            testConnection: checkBackendHealth,
            checkVersion: checkVersion,
            backend: BACKEND_URL,
            sendTest: () => sendQuickMessage('test'),
            testStream: () => sendQuickMessage('t·ªìn kho xi mƒÉng'),
            skipTypingDelay: () => {
                // H√†m debug ƒë·ªÉ skip delay khi test
                if (typingTimeout) {
                    clearTimeout(typingTimeout);
                    document.getElementById('typingIndicator').style.display = 'none';
                }
            }
        };
    </script>
</body>
</html>
